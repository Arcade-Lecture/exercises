# Task2

1. **Initializing your own local repository.**
   There are two ways to initialize a repository. Both of them start off with "git init" command. The command creates an empty git repository.

    * Creating a brand new repository.
      * Create a new directory for your project.
      * Enter the new directory.
      * Initilize repository by running `$ git init`.
      * Add the files to be committed using git add.
      * Run git commit to presist changes.
      
    * Creating a repository for exisisting project.
      * Go to the directory housing the project.
      * Initilize repository by running git init.
      * Add the files to be committed using git add.
      * Run git commit to presist changes.
      
      Post initialization the working directory will contain .git folder with subdirectories for tracking the changes to the working dir.
    
2. **Remote repositories and branching workflows.**

| Workflow      | #remote repositories| #remote branches    | branch lifetime |Responsibility to merge| Benefit            | Drawback              |
|:-------------:|:-------------------:|:-------------------:|:---------------:|:---------------------:|:-----------------: |:---------------------:|
| Centralized   | one                 | one                 | permenant       | user responsible for changes|simple            |conflicts if lot of upstream changes|
| Feature branch| one                 | one to many         | till the feature is merged| user responsible for changes |collaboration with team|can lead to polluted git history   |
| Git Flow      | one                 | two to many         | temporary/permanent| user responsible for changes            |suitable for large scale projects |complex            | 
| Forking       | two to many         | one to many         | temporary/permanent| repo maintainer          |suitable for opensource projects | suitable for long living projects accepting external contrubutions|
 
Choosing a workflow not compatiable with the upstream repo will lead to problems. For example if the official code base follows forking workflow then pull requests generated by other git workflows might be rejected even though the work is correct. 

Rule of thumb for using workflows: 

Centralized   : Short lived projects with small team and independent features.
Feature branch: For projects with many enhancements and medium sized teams.
Git flow      : For large scale projects with many releases.
Forking       : For opensource projects

3. **Committing one out of two.**
   If you have mutliple modified files which should be committed seperately follow the below procedure.
    
   * Suppose you have two files A and B to be committed. A should be committed before B.
    * Stage A by executing `$ git add A`.
    * Commit A by executing `$ git commit -m "Comitting A"`.
    * Repeate the above two steps for B.
4. **Ignoring files.**
   If you want to ignore files that are specific to your machine then add them to `.git/info/exclude` file present under root directory of git repo.
   Same rules that apply to `.gitignore` file applies to `exclude` file too. 
   
5. **Merging vs Rebasing.**
   Suppose you are working on a feature branch and you notice new commits on master branch which are relevant to your chnges. You have two options
   for incorporating those changes into your feature branch.
    * **Mearging master branch into feature branch**: Incorporates the new commits on master as a new merge commit at the 
    head of the feature branch. Merging very active branches will result in polluted git history. So in this case rebase option should be explored.
    * **Rebase the feature branch onto master**: Moves the feature branch to the current beginning of the master. 
    This is achieved by creating a new commit for each of the commit on the feature branch. 
    With rebasing we cant identify when the upstream changes were incorporated into the feature branch.
    
 6. **Rewriting History.**    
    * To change the commit message of the latest commit use `$ git commit --amend` or `$ git commit --amend -m "new commit message"`
    * To change a commit message of some old commit run `$ git rebase -i` on the branch having the commit you want to modify and use `$ git commit --amend`.
    
 7. **Stash your work.**
    Use `$ git stash` to save the ongoing modifications in your current branch before switching to new branch. This will revert the working branch to the HEAD.
    When you are ready to continue with your work apply stashed changes to the corresponding branch with `$ git stash apply`
    
    There are many ways you can organize your work when dealing with git, here is a comparission
between different kinds of workflows:





    
